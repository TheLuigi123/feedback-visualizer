<!DOCTYPE html>
<html>
<head>
    <title>Feedback Dashboard</title>
    <!-- Add flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
      /* CSS - Includes latest layout and font size adjustments */
      body {
            font-family: sans-serif;
            text-align: center;
            margin: 0;
            font-size: 2em; /* Base font size */
        }
      #date-controls {
            margin-bottom: 20px;
            padding: 30px 10px 15px 10px; /* Added padding top/bottom */
            /* Center the controls */
            display: flex;
            justify-content: center;
            align-items: center;
        }
      /* Style the date display element directly */
      #date-display {
          font-size: 1.5em; /* <<< Ensure desired font size */
          margin: 0 15px;   /* <<< Adjust margin as needed */
          cursor: pointer; /* Indicate it's clickable for the calendar */
          border-bottom: 1px dashed #ccc; /* Optional: subtle visual cue */
          padding: 5px 8px; /* Add some padding for better clicking */
          display: inline-block; /* Needed for proper spacing/border */
          /* Ensure flatpickr input inherits styles */
          line-height: normal; /* Override potential flatpickr styles */
          color: inherit; /* Use body text color */
          background: none; /* No background */
          border: none; /* Flatpickr might add its own border, override if necessary */
          text-align: center; /* Center text within the element */
          min-width: 250px; /* Give it some minimum width */
      }
      /* Override flatpickr default input styling if needed */
      .flatpickr-input {
          font-size: inherit !important; /* Force inherit font size */
          font-family: inherit !important; /* Force inherit font family */
          color: inherit !important;
          background: none !important;
          border: none !important; /* Remove flatpickr border */
          padding: 0 !important; /* Remove flatpickr padding */
          margin: 0 !important;
          text-align: center !important; /* Center text */
          box-shadow: none !important; /* Remove flatpickr shadow */
          outline: none !important; /* Remove focus outline */
          width: auto !important; /* Allow it to size naturally */
          display: inline-block !important;
          box-sizing: content-box !important; /* Prevent box model issues */
          height: auto !important; /* Reset height */
      }


      .arrow { cursor: pointer; font-size: 1.5em; padding: 5px; }

      #group-counts {
        margin-top: 20px;
        text-align: left;
        width: 100%;
        padding: 0 10px;
        box-sizing: border-box;
        min-height: 50px;
        vertical-align: top;
        display: flex;
        flex-direction: column;
        align-items: stretch;
      }

      #color-filters {
          margin-top: 25px;
          margin-bottom: 15px;
          text-align: center;
      }
      .color-filter-circle {
          display: inline-block;
          width: 30px;
          height: 30px;
          border-radius: 50%;
          margin: 0 10px;
          cursor: pointer;
          border: 2px solid transparent;
          opacity: 0.4;
          transition: opacity 0.3s ease, border-color 0.3s ease;
      }
      .color-filter-circle.filter-green { background-color: green; }
      .color-filter-circle.filter-yellow { background-color: yellow; }
      .color-filter-circle.filter-red { background-color: red; }

      .color-filter-circle:hover { opacity: 0.7; }
      .color-filter-circle.active { opacity: 1; border-color: #555; }

      #comments-display {
        text-align: left;
        margin-top: 20px;
        width: 100%;
        padding: 0 10px;
        box-sizing: border-box;
        font-size: 1.5em;
      }

      .group-count {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
      }
      .group-name {
            white-space: nowrap;
            width: 120px;
            text-align: left;
            flex-shrink: 0;
            margin-right: 60px;
        }
      .bar-chart {
            display: flex;
            width: 100%;
            height: 20px;
            border: 1px solid #eee;
            overflow: hidden;
        }

      .bar { height: 100%; }
      .button-1 { background-color: green; }
      .button-2 { background-color: yellow; }
      .button-3 { background-color: red; }

      .group-total {
        font-size: 0.9em;
        margin-left: 20px;
        white-space: nowrap;
        }
    </style>
</head>
<body>

    <div id="date-controls">
        <span class="arrow" onclick="changeDate(-1)"><</span>
        <!-- This single span will be enhanced by flatpickr -->
        <span id="date-display">Loading...</span>
        <span class="arrow" onclick="changeDate(1)">></span>
    </div>

    <div id="group-counts">Initializing...</div>

    <div id="color-filters">
        <span class="color-filter-circle filter-green" data-color-value="1" title="Filter Green Comments" onclick="handleColorFilterClick(this, 1)"></span>
        <span class="color-filter-circle filter-yellow" data-color-value="2" title="Filter Yellow Comments" onclick="handleColorFilterClick(this, 2)"></span>
        <span class="color-filter-circle filter-red" data-color-value="3" title="Filter Red Comments" onclick="handleColorFilterClick(this, 3)"></span>
    </div>

    <hr style="margin: 0 0 20px 0;">
    <div id="comments-display"></div>

    <!-- Load GAPI library -->
    <script async defer src="https://apis.google.com/js/api.js" onload="gisLoaded()"></script>
    <!-- Load flatpickr library -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <script>
         // --- Helper Functions ---
         function formatDate(date) {
          // Format for backend matching (DD/MM/YY)
          const day = String(date.getDate()).padStart(2, '0');
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const year = String(date.getFullYear()).slice(2);
          return `${day}/${month}/${year}`;
        }

        function getWeekday(date) {
          return weekdays[date.getDay()];
        }

         function calculateGlobalMax(allData) {
            // ... (function remains the same)
            const dailyGroupTotals = {};
            let maxFound = 0;

            if (allData && allData.length > 1) {
                for (let i = 1; i < allData.length; i++) {
                const row = allData[i];
                if (!row || row.length < 2 || !row[0] || !row[1]) {
                    continue;
                }

                const timestamp = row[0]; // Expect string like DD/MM/YY HH:MM:SS
                const group = row[1];
                let datePart = '';

                if (typeof timestamp === 'string') {
                    // Extract DD/MM/YY part
                    const match = timestamp.match(/^(\d{1,2}\/\d{1,2}\/\d{2,4})/);
                    if (match) {
                        // Ensure DD/MM/YY format for key
                        const dateParts = match[1].split('/');
                        if (dateParts.length === 3) {
                                const day = String(dateParts[0]).padStart(2,'0');
                                const month = String(dateParts[1]).padStart(2,'0');
                                const year = dateParts[2].length === 4 ? dateParts[2].slice(2) : String(dateParts[2]).padStart(2,'0');
                                datePart = `${day}/${month}/${year}`;
                        } else continue;
                    } else continue;
                } else {
                    continue;
                }

                if (!dailyGroupTotals[datePart]) dailyGroupTotals[datePart] = {};
                if (!dailyGroupTotals[datePart][group]) dailyGroupTotals[datePart][group] = 0;

                dailyGroupTotals[datePart][group]++;

                if (dailyGroupTotals[datePart][group] > maxFound) {
                    maxFound = dailyGroupTotals[datePart][group];
                }
                }
            }
            console.log("Global Max Daily Group Count Calculated:", maxFound);
            return maxFound;
         }


       function updateStatus(message, isError = false) {
            // ... (function remains mostly the same)
            console[isError ? 'error' : 'log']("Status:", message);
            const groupCountsContainer = document.getElementById('group-counts');
            const commentsContainer = document.getElementById('comments-display');
            const dateDisplay = document.getElementById('date-display'); // Reference the date element

            if (groupCountsContainer) groupCountsContainer.textContent = message;
            // if (commentsContainer) commentsContainer.innerHTML = ""; // Clear comments on status update/error?

            if (isError) {
                // If there's an error, still try to show something in the date display
                 if (dateDisplay && !calendarInstance) { // Only update text if calendar isn't working
                     dateDisplay.textContent = "Error";
                 } else if (dateDisplay) {
                     // Maybe disable calendar on error? Or just show error in counts area.
                     console.warn("Error occurred, keeping calendar active if initialized.");
                 }
            } else if (dateDisplay && !calendarInstance && message.startsWith("Loading")){
                // Show Loading... in date display only if calendar not ready
                dateDisplay.textContent = "Loading...";
            }
            // setDateDisplay() will be called when data is ready or date changes
       }

        // This function NOW primarily updates the flatpickr instance
        function setDateDisplay() {
          try {
              // Update the flatpickr calendar's date.
              // Flatpickr itself will handle updating the text in the #date-display element
              // based on the dateFormat specified during initialization.
            if (calendarInstance) {
                calendarInstance.setDate(currentDate, false); // Update calendar without triggering onChange
                 console.log("setDateDisplay updated calendar instance to:", currentDate);
            } else {
                 // Fallback if calendar hasn't loaded yet (e.g., initial load)
                 // We still need *some* text visible initially.
                 const dateDisplay = document.getElementById('date-display');
                 if (dateDisplay) {
                     const weekday = getWeekday(currentDate);
                     const formattedDateForDisplay = flatpickr.formatDate(currentDate, "l, d/m/y"); // Use flatpickr format
                     dateDisplay.textContent = formattedDateForDisplay;
                 }
                console.warn("Calendar instance not ready, set text content as fallback.");
            }
        } catch (error) {
            console.error("Error setting date display:", error);
            const dateDisplay = document.getElementById('date-display');
            if(dateDisplay) dateDisplay.textContent = "Date Error"; // Show error in the display
        }
        }
      // --- Constants ---
      const SPREADSHEET_ID = '1DIKTyqRujOEF6TbfhxF5UvZvu1O81o0gtF_5DANYbJQ';
      const SHEET_NAME = 'Sheet1';
      const API_KEY = 'AIzaSyDG2mNypu1h7Zl2eQhK2IFBDIBgLvYX1Pk'; // Keep secure

      console.log("Constants defined");

      // --- State Variables ---
      let currentDate = new Date();
      let globalMaxDailyGroupCount = 0;
      let gapiInitialized = false;
      let calendarInstance = null;
      let activeColorFilter = null;
      let currentDayCommentsData = {};

      const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
      const groupOrder = ["Besucher", "Lehrer", "9-12 Klasse", "5-8 Klasse", "1-4 Klasse"];
      const buttonNumbers = [1, 2, 3];

      // --- GAPI Initialization Flow ---

      function gisLoaded() {
        console.log("GAPI script loaded (gisLoaded called). Loading 'client:auth2' modules...");
        // Set initial date text before full API load, using fallback method
        setDateDisplay();
        updateStatus("Loading API modules...");
        gapi.load('client:auth2', initializeGapiClient);
      }

      function initializeGapiClient() {
          console.log("'client:auth2' modules loaded. Initializing GAPI client...");
          updateStatus("Initializing API client...");
          // Set date again in case it took time
          setDateDisplay();

          try {
            gapi.client.init({
                apiKey: API_KEY,
                discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
            }).then(() => {
                console.log("gapi.client.init resolved.");
                if (gapi.client.sheets && gapi.client.sheets.spreadsheets) {
                     console.log("Sheets API client available.");
                     gapiInitialized = true;

                     // Initialize flatpickr Calendar HERE after GAPI is ready
                     initializeCalendar();
                     // Now that calendar is initialized, set the date definitively via the instance
                     setDateDisplay(); // This will now use calendarInstance.setDate

                     updateStatus("Fetching data to calculate scale...");
                     fetchDataForScaleCalculation();
                } else {
                     // ... error handling ...
                     console.error("gapi.client.init succeeded BUT gapi.client.sheets is NOT available!");
                     updateStatus("Error: Sheets API structure not found.", true);
                     gapiInitialized = false;
                     setDateDisplay(); // Try to update date text even on error
                }
            }).catch(err => {
                console.error("Error during gapi.client.init promise:", err);
                handleInitError(err);
                gapiInitialized = false;
                setDateDisplay(); // Try to update date text even on error
            });
            console.log("gapi.client.init call issued (asynchronously).");
          } catch (error) {
            console.error("Synchronous error during gapi.client.init setup:", error);
            updateStatus(`Initialization Code Error: ${error.message}`, true);
            gapiInitialized = false;
            setDateDisplay(); // Try to update date text even on error
          }
      }

       // Initialize Flatpickr
       function initializeCalendar() {
           const dateDisplayElement = document.getElementById('date-display');
           if (dateDisplayElement && !calendarInstance) { // Prevent re-initialization
               calendarInstance = flatpickr(dateDisplayElement, {
                   // Format for display inside the element (Weekday, DD/MM/YY)
                   dateFormat: "l, d/m/y",
                   defaultDate: currentDate,
                   altInput: false, // Modify the original element directly
                   allowInput: false, // Prevent manual typing into the span
                   // We don't need altFormat if altInput is false
                   onChange: function(selectedDates, dateStr, instance) {
                       if (selectedDates.length > 0) {
                           console.log("Calendar date selected:", selectedDates[0]);
                           // Check if the date actually changed
                           if (formatDate(selectedDates[0]) !== formatDate(currentDate)) {
                               currentDate = selectedDates[0];
                               // setDateDisplay(); // No longer needed here, flatpickr updates display
                               resetColorFilters();
                               displayGroupCounts(); // Fetch data for the new date
                           }
                       }
                   },
                   // Optional: Add hook to ensure style consistency after render
                    onReady: function(selectedDates, dateStr, instance) {
                        instance.input.readOnly = true; // Make the underlying input readonly
                        // Ensure styles are applied correctly (might help if CSS is flaky)
                        instance.input.style.fontSize = 'inherit';
                        instance.input.style.textAlign = 'center';
                    },
                    onOpen: function(selectedDates, dateStr, instance) {
                        // Optional: Add class when calendar is open if needed for styling
                    },
                    onClose: function(selectedDates, dateStr, instance) {
                         // Optional: Remove class when calendar closes
                    }
               });
               console.log("Flatpickr calendar initialized.");
           } else if (!dateDisplayElement) {
               console.error("Could not find #date-display to initialize calendar.");
           } else {
               console.log("Flatpickr already initialized.");
           }
       }


      function handleInitError(err) {
           // ... (error handling remains the same)
           let errorMsg = err.result?.error?.message || err.message || 'Unknown init error';
           // ... (rest of error handling as before)
           console.error("Initialization Error Details:", err);
           updateStatus(`Initialization Error: ${errorMsg}`, true);
      }

      function fetchDataForScaleCalculation() {
           // ... (function remains the same)
            if (!gapiInitialized) {
               updateStatus("Error: Cannot fetch scale data, GAPI not initialized.", true);
               return;
            }
            console.log("Fetching A:B range for scale calculation...");
            try {
            gapi.client.sheets.spreadsheets.values.get({
                spreadsheetId: SPREADSHEET_ID,
                range: `${SHEET_NAME}!A:B`,
                dateTimeRenderOption: 'FORMATTED_STRING',
                valueRenderOption: 'FORMATTED_VALUE'
            }).then(response => {
                 console.log("Successfully fetched A:B data.");
                 const allData = response.result.values;
                 globalMaxDailyGroupCount = calculateGlobalMax(allData);

                 if (globalMaxDailyGroupCount <= 0) {
                     console.warn("No data found or max count is zero after scale calculation.");
                     updateStatus("No feedback data found in the sheet.");
                    //  setDateDisplay(); // Date already set
                     displayGroupCounts();
                 } else {
                     console.log("Scale calculated. Displaying initial data.");
                    //  setDateDisplay(); // Date already set
                     displayGroupCounts();
                 }
            }).catch(err => {
                console.error("Error fetching A:B data:", err);
                let errorMsg = err.result?.error?.message || err.message || 'Unknown fetch error';
                updateStatus(`Error fetching scale data: ${errorMsg}`, true);
            });
          } catch (error) {
              console.error("Synchronous error calling sheets.spreadsheets.values.get for scale:", error);
              updateStatus(`Critical Error fetching scale data: ${error.message}`, true);
           }
      }

       function displayGroupCounts() {
           // ... (function remains largely the same - data fetching and processing)
            if (!gapiInitialized) {
                // ... handle not initialized
                return;
            }

            const formattedDate = formatDate(currentDate); // DD/MM/YY for matching
            const range = `${SHEET_NAME}!A:E`;
            const groupCountsContainer = document.getElementById('group-counts');
            const commentsContainer = document.getElementById('comments-display');

            if (!groupCountsContainer || !commentsContainer) {
                // ... handle missing elements
                return;
            }

            groupCountsContainer.innerHTML = "Loading day data...";
            commentsContainer.innerHTML = "";
            currentDayCommentsData = {};

            console.log(`Fetching ${range} range for date: ${formattedDate}...`);

            try {
                gapi.client.sheets.spreadsheets.values.get({
                    spreadsheetId: SPREADSHEET_ID,
                    range: range,
                    dateTimeRenderOption: 'FORMATTED_STRING',
                    valueRenderOption: 'FORMATTED_VALUE'
                }).then(response => {
                    console.log(`Successfully fetched ${range} data for ${formattedDate}.`);
                    groupCountsContainer.innerHTML = ""; // Clear "Loading..."

                    const data = response.result.values;
                    const groupButtonCounts = {};
                    const groupTotals = {};
                    currentDayCommentsData = {};
                    let foundDataForDate = false;

                    // --- Data Processing Loop ---
                    if (data && data.length > 1) {
                        for (let i = 1; i < data.length; i++) {
                            const row = data[i];
                            if (!row || row.length < 3 || !row[0] || !row[1] || !row[2]) continue;

                            const timestamp = row[0];
                            const group = String(row[1]).trim();
                            const button = parseInt(row[2]);
                            const comment = (row.length > 4 && row[4]) ? String(row[4]).trim() : null;

                            let rowDatePart = '';
                             if (typeof timestamp === 'string') {
                                 const match = timestamp.match(/^(\d{1,2}\/\d{1,2}\/\d{2,4})/);
                                 if (match) {
                                      const dateParts = match[1].split('/');
                                       if (dateParts.length === 3) {
                                            const day = String(dateParts[0]).padStart(2,'0');
                                            const month = String(dateParts[1]).padStart(2,'0');
                                            const year = dateParts[2].length === 4 ? dateParts[2].slice(2) : String(dateParts[2]).padStart(2,'0');
                                            rowDatePart = `${day}/${month}/${year}`;
                                       } else continue;
                                 } else continue;
                             } else continue;


                            if (rowDatePart === formattedDate && group && groupOrder.includes(group) && !isNaN(button) && buttonNumbers.includes(button)) {
                                foundDataForDate = true;

                                // Aggregate counts
                                if (!groupButtonCounts[group]) groupButtonCounts[group] = {};
                                groupButtonCounts[group][button] = (groupButtonCounts[group][button] || 0) + 1;
                                groupTotals[group] = (groupTotals[group] || 0) + 1;

                                // Aggregate comments with color
                                if (comment && comment.length > 0) {
                                    if (!currentDayCommentsData[group]) currentDayCommentsData[group] = [];
                                    currentDayCommentsData[group].push({ text: comment, color: button });
                                }
                            }
                        }
                    } else {
                        console.log("No data rows returned from the sheet.");
                    }

                    // --- Render Group Counts and Bars ---
                    groupOrder.forEach(group => {
                        // ... (Rendering logic for bars remains the same)
                        const totalCountForDay = groupTotals[group] || 0;
                        const groupCountDiv = document.createElement('div');
                        groupCountDiv.className = 'group-count';
                        const groupNameSpan = document.createElement('span');
                        groupNameSpan.className = 'group-name';
                        groupNameSpan.textContent = `${group}:`;
                        groupCountDiv.appendChild(groupNameSpan);
                        const barChartDiv = document.createElement('div');
                        barChartDiv.className = 'bar-chart';
                        if (totalCountForDay > 0 && globalMaxDailyGroupCount > 0) {
                            buttonNumbers.forEach(button => {
                                const buttonCountForDay = groupButtonCounts[group]?.[button] || 0;
                                const percentage = globalMaxDailyGroupCount > 0 ? (buttonCountForDay / globalMaxDailyGroupCount) * 100 : 0;

                                if (percentage > 0) {
                                    const barDiv = document.createElement('div');
                                    barDiv.className = `bar button-${button}`;
                                    barDiv.style.width = `${percentage}%`;
                                    barDiv.title = `Button ${button}: ${buttonCountForDay}`;
                                    barChartDiv.appendChild(barDiv);
                                }
                            });
                        }
                         groupCountDiv.appendChild(barChartDiv);

                        const totalCountSpan = document.createElement('span');
                        totalCountSpan.className = 'group-total';
                        totalCountSpan.textContent = `(${totalCountForDay})`;
                        groupCountDiv.appendChild(totalCountSpan);
                        groupCountsContainer.appendChild(groupCountDiv);
                    });

                    if (!foundDataForDate && groupCountsContainer.innerHTML === "") {
                        groupCountsContainer.textContent = "No data found for this date.";
                    }

                    // --- Render Comments (Initial render based on stored data and current filter) ---
                     renderComments();

                }).catch(err => {
                    // ... (error handling for fetch remains the same)
                    console.error(`Error fetching or processing data for ${formattedDate}:`, err);
                    let errorMsg = err.result?.error?.message || err.message || 'Unknown error during data display';
                    updateStatus(`Error displaying data: ${errorMsg}`, true);
                    groupCountsContainer.innerHTML = `Error loading data for ${formattedDate}.`;
                    commentsContainer.innerHTML = "";
                    currentDayCommentsData = {};
                });
            } catch (error) {
                console.error(`Synchronous error in displayGroupCounts for ${formattedDate}:`, error);
                updateStatus(`Code error displaying data: ${error.message}`, true);
            }
       }

       function renderComments() {
            // ... (function remains the same)
            const commentsContainer = document.getElementById('comments-display');
            if (!commentsContainer) return;

            commentsContainer.innerHTML = ""; // Clear previous comments
            let commentsFoundForFilter = false;

            groupOrder.forEach(group => {
                const commentsForGroup = currentDayCommentsData[group] || []; // Get stored comments for the group

                const filteredComments = commentsForGroup.filter(comment => {
                    return activeColorFilter === null || comment.color === activeColorFilter;
                });

                if (filteredComments.length > 0) {
                    commentsFoundForFilter = true;

                    const commentBlock = document.createElement('div');
                    commentBlock.style.marginBottom = '15px';

                    const nameLabel = document.createElement('strong');
                    nameLabel.textContent = `${group}: `;
                    commentBlock.appendChild(nameLabel);

                    commentBlock.appendChild(document.createTextNode(filteredComments.map(c => c.text).join(' | ')));
                    commentsContainer.appendChild(commentBlock);
                }
            });

            if (!commentsFoundForFilter) {
                 if (Object.keys(currentDayCommentsData).length === 0 && document.getElementById('group-counts')?.textContent !== "No data found for this date."){
                    // Only show "no comments" if there *was* data for the date but no actual comments.
                    commentsContainer.textContent = "No comments entered for this date.";
                 } else if (activeColorFilter !== null) {
                    const colors = { 1: 'green', 2: 'yellow', 3: 'red' };
                    commentsContainer.textContent = `No ${colors[activeColorFilter] || ''} comments for this date.`;
                 } else if (Object.keys(currentDayCommentsData).length > 0) {
                     // Data exists, no filter, but still no comments found (maybe comments only had empty strings?)
                     commentsContainer.textContent = "No comments entered for this date.";
                 } else {
                    // No data fetched at all, keep comments empty.
                    commentsContainer.innerHTML = "";
                 }
            }
       }

      function handleColorFilterClick(element, colorValue) {
            // ... (function remains the same)
            const circles = document.querySelectorAll('.color-filter-circle');

            if (element.classList.contains('active')) {
                element.classList.remove('active');
                activeColorFilter = null;
            } else {
                circles.forEach(circle => circle.classList.remove('active'));
                element.classList.add('active');
                activeColorFilter = colorValue;
            }
            renderComments();
      }

      function resetColorFilters() {
           // ... (function remains the same)
          const circles = document.querySelectorAll('.color-filter-circle');
          circles.forEach(circle => circle.classList.remove('active'));
          activeColorFilter = null;
      }

      function changeDate(delta) {
          // Calculate the new date
          const newDate = new Date(currentDate); // Clone current date
          newDate.setDate(newDate.getDate() + delta);
          currentDate = newDate; // Update the state variable

          // Update the display (which now uses flatpickr)
          setDateDisplay(); // This will call calendarInstance.setDate

          // Clear old data and filters
          const groupCountsContainer = document.getElementById('group-counts');
          const commentsContainer = document.getElementById('comments-display');
          if (groupCountsContainer) groupCountsContainer.innerHTML = "Loading...";
          if (commentsContainer) commentsContainer.innerHTML = "";
          resetColorFilters();

          // Fetch new data if GAPI is ready
          if (gapiInitialized) {
               displayGroupCounts();
          } else {
             // Handle case where GAPI isn't ready yet (should be rare after init)
             if (!groupCountsContainer?.textContent?.includes("Error")) {
                updateStatus("Cannot change date display: GAPI not initialized.", true);
             } else {
                 // Keep init error message but ensure date display reflects the change attempt
                 setDateDisplay();
             }
          }
      }

      // --- Initial Load Trigger ---
       // setDateDisplay(); // Called within gisLoaded now
       // gisLoaded(); // Called by the script tag's onload

    </script>
</body>
</html>
